{"version":3,"sources":["../../../../node_modules/%40swc/helpers/cjs/_interop_require_default.cjs","../../../../node_modules/next/src/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.tsx","../../../../node_modules/next/src/shared/lib/encode-uri-path.ts","../../../../node_modules/next/src/shared/lib/lazy-dynamic/preload-chunks.tsx","../../../../node_modules/next/src/shared/lib/lazy-dynamic/loadable.tsx","../../../../node_modules/next/src/shared/lib/app-dynamic.tsx","../../../../src/lib/services/tasks.ts","../../../../src/components/GanttWrapper.tsx","../../../../src/app/gantt/%5Bid%5D/page.tsx","../../../../src/lib/services/links.ts","../../../../node_modules/lucide-react/src/icons/save.ts"],"sourcesContent":["\"use strict\";\n\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\nexports._ = _interop_require_default;\n","'use client'\n\nimport type { ReactElement } from 'react'\nimport { BailoutToCSRError } from './bailout-to-csr'\n\ninterface BailoutToCSRProps {\n  reason: string\n  children: ReactElement\n}\n\n/**\n * If rendered on the server, this component throws an error\n * to signal Next.js that it should bail out to client-side rendering instead.\n */\nexport function BailoutToCSR({ reason, children }: BailoutToCSRProps) {\n  if (typeof window === 'undefined') {\n    throw new BailoutToCSRError(reason)\n  }\n\n  return children\n}\n","export function encodeURIPath(file: string) {\n  return file\n    .split('/')\n    .map((p) => encodeURIComponent(p))\n    .join('/')\n}\n","'use client'\n\nimport { preload } from 'react-dom'\n\nimport { workAsyncStorage } from '../../../server/app-render/work-async-storage.external'\nimport { encodeURIPath } from '../encode-uri-path'\n\nexport function PreloadChunks({\n  moduleIds,\n}: {\n  moduleIds: string[] | undefined\n}) {\n  // Early return in client compilation and only load requestStore on server side\n  if (typeof window !== 'undefined') {\n    return null\n  }\n\n  const workStore = workAsyncStorage.getStore()\n  if (workStore === undefined) {\n    return null\n  }\n\n  const allFiles = []\n\n  // Search the current dynamic call unique key id in react loadable manifest,\n  // and find the corresponding CSS files to preload\n  if (workStore.reactLoadableManifest && moduleIds) {\n    const manifest = workStore.reactLoadableManifest\n    for (const key of moduleIds) {\n      if (!manifest[key]) continue\n      const chunks = manifest[key].files\n      allFiles.push(...chunks)\n    }\n  }\n\n  if (allFiles.length === 0) {\n    return null\n  }\n\n  const dplId = process.env.NEXT_DEPLOYMENT_ID\n    ? `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`\n    : ''\n\n  return (\n    <>\n      {allFiles.map((chunk) => {\n        const href = `${workStore.assetPrefix}/_next/${encodeURIPath(chunk)}${dplId}`\n        const isCss = chunk.endsWith('.css')\n        // If it's stylesheet we use `precedence` o help hoist with React Float.\n        // For stylesheets we actually need to render the CSS because nothing else is going to do it so it needs to be part of the component tree.\n        // The `preload` for stylesheet is not optional.\n        if (isCss) {\n          return (\n            <link\n              key={chunk}\n              // @ts-ignore\n              precedence=\"dynamic\"\n              href={href}\n              rel=\"stylesheet\"\n              as=\"style\"\n              nonce={workStore.nonce}\n            />\n          )\n        } else {\n          // If it's script we use ReactDOM.preload to preload the resources\n          preload(href, {\n            as: 'script',\n            fetchPriority: 'low',\n            nonce: workStore.nonce,\n          })\n          return null\n        }\n      })}\n    </>\n  )\n}\n","import { Suspense, Fragment, lazy } from 'react'\nimport { BailoutToCSR } from './dynamic-bailout-to-csr'\nimport type { ComponentModule } from './types'\nimport { PreloadChunks } from './preload-chunks'\n\n// Normalize loader to return the module as form { default: Component } for `React.lazy`.\n// Also for backward compatible since next/dynamic allows to resolve a component directly with loader\n// Client component reference proxy need to be converted to a module.\nfunction convertModule<P>(\n  mod: React.ComponentType<P> | ComponentModule<P> | undefined\n): {\n  default: React.ComponentType<P>\n} {\n  // Check \"default\" prop before accessing it, as it could be client reference proxy that could break it reference.\n  // Cases:\n  // mod: { default: Component }\n  // mod: Component\n  // mod: { default: proxy(Component) }\n  // mod: proxy(Component)\n  const hasDefault = mod && 'default' in mod\n  return {\n    default: hasDefault\n      ? (mod as ComponentModule<P>).default\n      : (mod as React.ComponentType<P>),\n  }\n}\n\nconst defaultOptions = {\n  loader: () => Promise.resolve(convertModule(() => null)),\n  loading: null,\n  ssr: true,\n}\n\ninterface LoadableOptions {\n  loader?: () => Promise<React.ComponentType<any> | ComponentModule<any>>\n  loading?: React.ComponentType<any> | null\n  ssr?: boolean\n  modules?: string[]\n}\n\nfunction Loadable(options: LoadableOptions) {\n  const opts = { ...defaultOptions, ...options }\n  const Lazy = lazy(() => opts.loader().then(convertModule))\n  const Loading = opts.loading\n\n  function LoadableComponent(props: any) {\n    const fallbackElement = Loading ? (\n      <Loading isLoading={true} pastDelay={true} error={null} />\n    ) : null\n\n    // If it's non-SSR or provided a loading component, wrap it in a suspense boundary\n    const hasSuspenseBoundary = !opts.ssr || !!opts.loading\n    const Wrap = hasSuspenseBoundary ? Suspense : Fragment\n    const wrapProps = hasSuspenseBoundary ? { fallback: fallbackElement } : {}\n    const children = opts.ssr ? (\n      <>\n        {/* During SSR, we need to preload the CSS from the dynamic component to avoid flash of unstyled content */}\n        {typeof window === 'undefined' ? (\n          <PreloadChunks moduleIds={opts.modules} />\n        ) : null}\n        <Lazy {...props} />\n      </>\n    ) : (\n      <BailoutToCSR reason=\"next/dynamic\">\n        <Lazy {...props} />\n      </BailoutToCSR>\n    )\n\n    return <Wrap {...wrapProps}>{children}</Wrap>\n  }\n\n  LoadableComponent.displayName = 'LoadableComponent'\n\n  return LoadableComponent\n}\n\nexport default Loadable\n","import type React from 'react'\nimport type { JSX } from 'react'\nimport Loadable from './lazy-dynamic/loadable'\n\nimport type {\n  LoadableGeneratedOptions,\n  DynamicOptionsLoadingProps,\n  Loader,\n  LoaderComponent,\n} from './lazy-dynamic/types'\n\nexport {\n  type LoadableGeneratedOptions,\n  type DynamicOptionsLoadingProps,\n  type Loader,\n  type LoaderComponent,\n}\n\nexport type DynamicOptions<P = {}> = LoadableGeneratedOptions & {\n  loading?: () => JSX.Element | null\n  loader?: Loader<P>\n  loadableGenerated?: LoadableGeneratedOptions\n  modules?: string[]\n  ssr?: boolean\n}\n\nexport type LoadableOptions<P = {}> = DynamicOptions<P>\n\nexport type LoadableFn<P = {}> = (\n  opts: LoadableOptions<P>\n) => React.ComponentType<P>\n\nexport type LoadableComponent<P = {}> = React.ComponentType<P>\n\nexport default function dynamic<P = {}>(\n  dynamicOptions: DynamicOptions<P> | Loader<P>,\n  options?: DynamicOptions<P>\n): React.ComponentType<P> {\n  const loadableOptions: LoadableOptions<P> = {}\n\n  if (typeof dynamicOptions === 'function') {\n    loadableOptions.loader = dynamicOptions\n  }\n\n  const mergedOptions = {\n    ...loadableOptions,\n    ...options,\n  }\n\n  return Loadable({\n    ...mergedOptions,\n    modules: mergedOptions.loadableGenerated?.modules,\n  })\n}\n","/**\n * Tasks Service\n * Task CRUD 작업을 담당합니다.\n */\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport type { TaskDTO, Task } from \"@/lib/gantt/types\";\nimport { decorateTask } from \"@/lib/gantt/utils\";\nimport { getMockTasks } from \"./mockStorage\";\n\n// Check if Supabase is configured\nconst USE_MOCK =\n  !process.env.NEXT_PUBLIC_SUPABASE_URL ||\n  !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ||\n  process.env.NEXT_PUBLIC_USE_MOCK === \"true\";\n\n/**\n * Get all tasks for a Gantt chart\n */\nexport async function getTasks(ganttChartId: string): Promise<Task[]> {\n  if (USE_MOCK) {\n    return getMockTasks(ganttChartId);\n  }\n\n  const supabase = createClient();\n\n  const { data, error } = await supabase\n    .from(\"tasks\")\n    .select(\"*\")\n    .eq(\"gantt_chart_id\", ganttChartId)\n    .order(\"position\", { ascending: true });\n\n  if (error) {\n    console.error(\"Error fetching tasks:\", error);\n    return getMockTasks(ganttChartId);\n  }\n\n  // Convert DTO to Task with decorated properties\n  return (data as TaskDTO[]).map((taskDto) => {\n    const task: Partial<Task> = {\n      id: taskDto.id,\n      text: taskDto.text,\n      type: taskDto.type,\n      start: taskDto.start_date,\n      end: taskDto.end_date,\n      progress: taskDto.progress,\n      parent: taskDto.parent_id,\n      position: taskDto.position,\n      open: taskDto.open,\n      assigned: taskDto.assigned_to,\n      category: taskDto.category,\n      workType: taskDto.work_type,\n    };\n\n    return decorateTask(task);\n  });\n}\n\n/**\n * Get a single task by ID\n */\nexport async function getTask(id: string | number): Promise<Task | null> {\n  const supabase = createClient();\n\n  const { data, error } = await supabase\n    .from(\"tasks\")\n    .select(\"*\")\n    .eq(\"id\", id)\n    .single();\n\n  if (error) {\n    if (error.code === \"PGRST116\") {\n      // Not found\n      return null;\n    }\n    console.error(\"Error fetching task:\", error);\n    throw new Error(\"Failed to fetch task\");\n  }\n\n  const taskDto = data as TaskDTO;\n  const task: Partial<Task> = {\n    id: taskDto.id,\n    text: taskDto.text,\n    type: taskDto.type,\n    start: taskDto.start_date,\n    end: taskDto.end_date,\n    progress: taskDto.progress,\n    parent: taskDto.parent_id,\n    position: taskDto.position,\n    open: taskDto.open,\n    assigned: taskDto.assigned_to,\n    category: taskDto.category,\n    workType: taskDto.work_type,\n  };\n\n  return decorateTask(task);\n}\n\n/**\n * Create a new task\n */\nexport async function createTask(task: Partial<Task>, ganttChartId: string): Promise<Task> {\n  const supabase = createClient();\n\n  const taskDto: Partial<TaskDTO> = {\n    gantt_chart_id: ganttChartId,\n    text: task.text,\n    type: task.type,\n    start_date: typeof task.start === \"string\" ? task.start : task.start?.toISOString().split(\"T\")[0],\n    end_date: task.end ? (typeof task.end === \"string\" ? task.end : task.end.toISOString().split(\"T\")[0]) : undefined,\n    progress: task.progress ?? 0,\n    parent_id: task.parent !== undefined ? String(task.parent) : undefined,\n    position: task.position ?? 0,\n    open: task.open ?? true,\n    assigned_to: task.assigned !== undefined ? String(task.assigned) : undefined,\n    category: task.category,\n    work_type: task.workType,\n  };\n\n  const { data, error } = await supabase\n    .from(\"tasks\")\n    .insert(taskDto)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(\"Error creating task:\", error);\n    throw new Error(\"Failed to create task\");\n  }\n\n  const createdDto = data as TaskDTO;\n  const createdTask: Partial<Task> = {\n    id: createdDto.id,\n    text: createdDto.text,\n    type: createdDto.type,\n    start: createdDto.start_date,\n    end: createdDto.end_date,\n    progress: createdDto.progress,\n    parent: createdDto.parent_id,\n    position: createdDto.position,\n    open: createdDto.open,\n    assigned: createdDto.assigned_to,\n    category: createdDto.category,\n    workType: createdDto.work_type,\n  };\n\n  return decorateTask(createdTask);\n}\n\n/**\n * Update a task\n */\nexport async function updateTask(\n  id: string | number,\n  updates: Partial<Task>\n): Promise<Task> {\n  const supabase = createClient();\n\n  const taskDto: Partial<TaskDTO> = {};\n  if (updates.text !== undefined) taskDto.text = updates.text;\n  if (updates.type !== undefined) taskDto.type = updates.type;\n  if (updates.start !== undefined) {\n    taskDto.start_date = typeof updates.start === \"string\" ? updates.start : updates.start.toISOString().split(\"T\")[0];\n  }\n  if (updates.end !== undefined) {\n    taskDto.end_date = updates.end ? (typeof updates.end === \"string\" ? updates.end : updates.end.toISOString().split(\"T\")[0]) : undefined;\n  }\n  if (updates.progress !== undefined) taskDto.progress = updates.progress;\n  if (updates.parent !== undefined) taskDto.parent_id = String(updates.parent);\n  if (updates.position !== undefined) taskDto.position = updates.position;\n  if (updates.open !== undefined) taskDto.open = updates.open;\n  if (updates.assigned !== undefined) taskDto.assigned_to = String(updates.assigned);\n  if (updates.category !== undefined) taskDto.category = updates.category;\n  if (updates.workType !== undefined) taskDto.work_type = updates.workType;\n\n  const { data, error } = await supabase\n    .from(\"tasks\")\n    .update(taskDto)\n    .eq(\"id\", id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(\"Error updating task:\", error);\n    throw new Error(\"Failed to update task\");\n  }\n\n  const updatedDto = data as TaskDTO;\n  const updatedTask: Partial<Task> = {\n    id: updatedDto.id,\n    text: updatedDto.text,\n    type: updatedDto.type,\n    start: updatedDto.start_date,\n    end: updatedDto.end_date,\n    progress: updatedDto.progress,\n    parent: updatedDto.parent_id,\n    position: updatedDto.position,\n    open: updatedDto.open,\n    assigned: updatedDto.assigned_to,\n    category: updatedDto.category,\n    workType: updatedDto.work_type,\n  };\n\n  return decorateTask(updatedTask);\n}\n\n/**\n * Delete a task\n */\nexport async function deleteTask(id: string | number): Promise<void> {\n  const supabase = createClient();\n\n  const { error } = await supabase.from(\"tasks\").delete().eq(\"id\", id);\n\n  if (error) {\n    console.error(\"Error deleting task:\", error);\n    throw new Error(\"Failed to delete task\");\n  }\n}\n\n/**\n * Batch create tasks\n */\nexport async function createTasksBatch(\n  tasks: Array<Partial<Task>>,\n  ganttChartId: string\n): Promise<Task[]> {\n  const supabase = createClient();\n\n  const taskDtos: Array<Partial<TaskDTO>> = tasks.map((task) => ({\n    gantt_chart_id: ganttChartId,\n    text: task.text,\n    type: task.type,\n    start_date: typeof task.start === \"string\" ? task.start : task.start?.toISOString().split(\"T\")[0],\n    end_date: task.end ? (typeof task.end === \"string\" ? task.end : task.end.toISOString().split(\"T\")[0]) : undefined,\n    progress: task.progress ?? 0,\n    parent_id: task.parent !== undefined ? String(task.parent) : undefined,\n    position: task.position ?? 0,\n    open: task.open ?? true,\n    assigned_to: task.assigned !== undefined ? String(task.assigned) : undefined,\n    category: task.category,\n    work_type: task.workType,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"tasks\")\n    .insert(taskDtos)\n    .select();\n\n  if (error) {\n    console.error(\"Error creating tasks batch:\", error);\n    throw new Error(\"Failed to create tasks batch\");\n  }\n\n  return (data as TaskDTO[]).map((taskDto) => {\n    const task: Partial<Task> = {\n      id: taskDto.id,\n      text: taskDto.text,\n      type: taskDto.type,\n      start: taskDto.start_date,\n      end: taskDto.end_date,\n      progress: taskDto.progress,\n      parent: taskDto.parent_id,\n      position: taskDto.position,\n      open: taskDto.open,\n      assigned: taskDto.assigned_to,\n      category: taskDto.category,\n      workType: taskDto.work_type,\n    };\n\n    return decorateTask(task);\n  });\n}\n\n","\"use client\";\n\nimport dynamic from \"next/dynamic\";\n\nconst GanttChart = dynamic(() => import(\"./GanttChart\").then((mod) => mod.GanttChart), {\n  ssr: false,\n  loading: () => <div className=\"flex h-full items-center justify-center\">Loading Gantt Chart...</div>,\n});\n\nexport function GanttWrapper() {\n  return <GanttChart />;\n}\n\n\n\n\n\n\n","/**\n * Gantt Chart Page\n * 개별 Gantt 차트를 표시하고 편집하는 페이지\n */\n\n\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { use } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport Link from \"next/link\";\nimport { GanttWrapper } from \"@/components/GanttWrapper\";\nimport { Button } from \"@/components/ui/Button\";\nimport { ArrowLeft, Save } from \"lucide-react\";\nimport { getGanttChart } from \"@/lib/services/ganttCharts\";\nimport { getTasks } from \"@/lib/services/tasks\";\nimport { getLinks } from \"@/lib/services/links\";\nimport { toast } from \"sonner\";\nimport type { Task, Link as GanttLink } from \"@/lib/gantt/types\";\n\ninterface GanttPageProps {\n  params: Promise<{ id: string }>;\n}\n\nexport default function GanttPage({ params }: GanttPageProps) {\n  const { id } = use(params);\n  const router = useRouter();\n\n  const [chart, setChart] = useState<{ name: string; project_id: string } | null>(null);\n  const [_tasks, setTasks] = useState<Task[]>([]);\n  const [_links, setLinks] = useState<GanttLink[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isSaving, setIsSaving] = useState(false);\n\n  // Load chart data\n  useEffect(() => {\n    async function loadData() {\n      try {\n        setIsLoading(true);\n        const [chartData, tasksData, linksData] = await Promise.all([\n          getGanttChart(id),\n          getTasks(id),\n          getLinks(id),\n        ]);\n\n        if (!chartData) {\n          toast.error(\"Gantt 차트를 찾을 수 없습니다\");\n          router.push(\"/dashboard\");\n          return;\n        }\n\n        setChart(chartData);\n        setTasks(tasksData);\n        setLinks(linksData);\n      } catch (error) {\n        console.error(\"Failed to load Gantt chart:\", error);\n        toast.error(\"Gantt 차트 로딩 실패\");\n      } finally {\n        setIsLoading(false);\n      }\n    }\n\n    void loadData();\n  }, [id, router]);\n\n  const handleSave = async () => {\n    try {\n      setIsSaving(true);\n      // TODO: Implement save logic with Supabase\n      toast.success(\"저장되었습니다\");\n    } catch (error) {\n      console.error(\"Save error:\", error);\n      toast.error(\"저장 실패\");\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex flex-col items-center justify-center min-h-screen\">\n        <div className=\"spinner\" />\n        <p className=\"mt-4 text-primary-600\">Gantt 차트 로딩 중...</p>\n      </div>\n    );\n  }\n\n  if (!chart) {\n    return null;\n  }\n\n  return (\n    <div className=\"flex flex-col h-screen\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between px-6 py-4 border-b border-primary-200 dark:border-primary-800 bg-white dark:bg-primary-900\">\n        <div className=\"flex items-center gap-4\">\n          <Link href={`/dashboard/projects/${chart.project_id}`}>\n            <Button variant=\"ghost\" size=\"sm\">\n              <ArrowLeft className=\"h-4 w-4 mr-2\" />\n              프로젝트로 돌아가기\n            </Button>\n          </Link>\n          <div>\n            <h1 className=\"text-xl font-bold text-primary-900 dark:text-primary-100\">\n              {chart.name}\n            </h1>\n          </div>\n        </div>\n        <Button\n          variant=\"primary\"\n          size=\"md\"\n          onClick={handleSave}\n          loading={isSaving}\n          disabled={isSaving}\n        >\n          <Save className=\"h-4 w-4 mr-2\" />\n          저장\n        </Button>\n      </div>\n\n      {/* Gantt Chart */}\n      <div className=\"flex-1 overflow-hidden\">\n        <GanttWrapper />\n      </div>\n    </div>\n  );\n}\n\n","/**\n * Links Service\n * Task 간의 의존성(Link) CRUD 작업을 담당합니다.\n */\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport type { Link, LinkDTO } from \"@/lib/gantt/types\";\nimport { getMockLinks } from \"./mockStorage\";\n\n// Check if Supabase is configured\nconst USE_MOCK =\n  !process.env.NEXT_PUBLIC_SUPABASE_URL ||\n  !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ||\n  process.env.NEXT_PUBLIC_USE_MOCK === \"true\";\n\n/**\n * Get all links for a Gantt chart\n */\nexport async function getLinks(ganttChartId: string): Promise<Link[]> {\n  if (USE_MOCK) {\n    return getMockLinks(ganttChartId);\n  }\n\n  const supabase = createClient();\n\n  const { data, error } = await supabase\n    .from(\"links\")\n    .select(\"*\")\n    .eq(\"gantt_chart_id\", ganttChartId);\n\n  if (error) {\n    console.error(\"Error fetching links:\", error);\n    return getMockLinks(ganttChartId);\n  }\n\n  // Convert DTO to Link\n  return (data as LinkDTO[]).map((linkDto) => ({\n    id: linkDto.id,\n    source: linkDto.source_task_id,\n    target: linkDto.target_task_id,\n    type: linkDto.type,\n  }));\n}\n\n/**\n * Get a single link by ID\n */\nexport async function getLink(id: string | number): Promise<Link | null> {\n  const supabase = createClient();\n\n  const { data, error } = await supabase\n    .from(\"links\")\n    .select(\"*\")\n    .eq(\"id\", id)\n    .single();\n\n  if (error) {\n    if (error.code === \"PGRST116\") {\n      // Not found\n      return null;\n    }\n    console.error(\"Error fetching link:\", error);\n    throw new Error(\"Failed to fetch link\");\n  }\n\n  const linkDto = data as LinkDTO;\n  return {\n    id: linkDto.id,\n    source: linkDto.source_task_id,\n    target: linkDto.target_task_id,\n    type: linkDto.type,\n  };\n}\n\n/**\n * Create a new link\n */\nexport async function createLink(link: Link, ganttChartId: string): Promise<Link> {\n  const supabase = createClient();\n\n  const linkDto: Partial<LinkDTO> = {\n    gantt_chart_id: ganttChartId,\n    source_task_id: link.source,\n    target_task_id: link.target,\n    type: link.type,\n  };\n\n  const { data, error } = await supabase\n    .from(\"links\")\n    .insert(linkDto)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(\"Error creating link:\", error);\n    throw new Error(\"Failed to create link\");\n  }\n\n  const createdDto = data as LinkDTO;\n  return {\n    id: createdDto.id,\n    source: createdDto.source_task_id,\n    target: createdDto.target_task_id,\n    type: createdDto.type,\n  };\n}\n\n/**\n * Update a link\n */\nexport async function updateLink(\n  id: string | number,\n  updates: Partial<Link>\n): Promise<Link> {\n  const supabase = createClient();\n\n  const linkDto: Partial<LinkDTO> = {};\n  if (updates.source !== undefined) linkDto.source_task_id = updates.source;\n  if (updates.target !== undefined) linkDto.target_task_id = updates.target;\n  if (updates.type !== undefined) linkDto.type = updates.type;\n\n  const { data, error } = await supabase\n    .from(\"links\")\n    .update(linkDto)\n    .eq(\"id\", id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(\"Error updating link:\", error);\n    throw new Error(\"Failed to update link\");\n  }\n\n  const updatedDto = data as LinkDTO;\n  return {\n    id: updatedDto.id,\n    source: updatedDto.source_task_id,\n    target: updatedDto.target_task_id,\n    type: updatedDto.type,\n  };\n}\n\n/**\n * Delete a link\n */\nexport async function deleteLink(id: string | number): Promise<void> {\n  const supabase = createClient();\n\n  const { error } = await supabase.from(\"links\").delete().eq(\"id\", id);\n\n  if (error) {\n    console.error(\"Error deleting link:\", error);\n    throw new Error(\"Failed to delete link\");\n  }\n}\n\n/**\n * Batch create links\n */\nexport async function createLinksBatch(\n  links: Link[],\n  ganttChartId: string\n): Promise<Link[]> {\n  const supabase = createClient();\n\n  const linkDtos: Array<Partial<LinkDTO>> = links.map((link) => ({\n    gantt_chart_id: ganttChartId,\n    source_task_id: link.source,\n    target_task_id: link.target,\n    type: link.type,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"links\")\n    .insert(linkDtos)\n    .select();\n\n  if (error) {\n    console.error(\"Error creating links batch:\", error);\n    throw new Error(\"Failed to create links batch\");\n  }\n\n  return (data as LinkDTO[]).map((linkDto) => ({\n    id: linkDto.id,\n    source: linkDto.source_task_id,\n    target: linkDto.target_task_id,\n    type: linkDto.type,\n  }));\n}\n\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z',\n      key: '1c8476',\n    },\n  ],\n  ['path', { d: 'M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7', key: '1ydtos' }],\n  ['path', { d: 'M7 3v4a1 1 0 0 0 1 1h7', key: 't51u73' }],\n];\n\n/**\n * @component @name Save\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTUuMiAzYTIgMiAwIDAgMSAxLjQuNmwzLjggMy44YTIgMiAwIDAgMSAuNiAxLjRWMTlhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yeiIgLz4KICA8cGF0aCBkPSJNMTcgMjF2LTdhMSAxIDAgMCAwLTEtMUg4YTEgMSAwIDAgMC0xIDF2NyIgLz4KICA8cGF0aCBkPSJNNyAzdjRhMSAxIDAgMCAwIDEgMWg3IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/save\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Save = createLucideIcon('save', __iconNode);\n\nexport default Save;\n"],"names":["BailoutToCSR","reason","children","window","BailoutToCSRError","encodeURIPath","file","split","map","p","encodeURIComponent","join","PreloadChunks","moduleIds","workStore","workAsyncStorage","getStore","undefined","allFiles","reactLoadableManifest","manifest","key","chunks","files","push","length","dplId","process","env","NEXT_DEPLOYMENT_ID","chunk","href","assetPrefix","isCss","endsWith","link","precedence","rel","as","nonce","preload","fetchPriority","convertModule","mod","hasDefault","default","defaultOptions","loader","Promise","resolve","loading","ssr","Loadable","options","opts","Lazy","lazy","then","Loading","LoadableComponent","props","fallbackElement","isLoading","pastDelay","error","hasSuspenseBoundary","Wrap","Suspense","Fragment","wrapProps","fallback","modules","displayName","dynamic","dynamicOptions","loadableOptions","mergedOptions","loadableGenerated"],"mappings":"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","ignoreList":[0,1,2,3,4,5,10]}